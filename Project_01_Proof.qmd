---
title: "Data Manipulation (EDIT TITLE)"
author: "Brock Akerman"
format: html
---

```{r setup, echo=T, output=F}
require(tidyverse)
options(readr.show_col_types = FALSE)
```

Data wrangling can present varying degrees of challenges.  If you are fortunate, issues present in the data your are working with may be corrected with a single line of Base R code in the console.  Data is messy and the task to wrangle it will often require a script of code to prepare it for analysis.

Using data from the Census Bureau's Statistical Compendia Program, we can massage the data into a format we can work with for analysis using the tidyverse.  In the following _Data Processing_ section, the effort to accomplish this task will look manual with a step-by-step demonstration of turning raw data into two tibbles that groups our data geographically using simple tidyverse functions.  In the _Combining Data Functions_ section, I will demonstrate an automative approach through nested functions.  This will allow for the replication of new datasets without having to recreate a new function each time we require the exact formatting using a similar dataset. Finally I will auto-plot the data in the _Putting it all together sections_.

# Data Processing

We cannot do anything without a dataset.  The first order of business is to introduce data to the R environment.  The readr package can read in our comma-separated value file and insert it as a tibble using the read_csv.  Since we will be working with two similarly-named URLs and datasets, I decided to name the tibble after the file name for organizational purpose.  In the next step, I would change the tibble name using best practices.

```{r, echo=TRUE, output=FALSE}
#Read-in the dataset.
EDU01a <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv")
```

With the data read in, I called on it in R to show how the tibble was structured.  Observe there are 3,198 row over 42 columns of double-character mixed data.  Not all of the columns are useful.  The next tidyverse column operation will be to limit to an object the columns that we are interested in.  Inside the select operation, there is a renaming of column "Area_name" and call to pull all columns ending in "D" using the ends_with operation.     

```{r, echo=TRUE, output=FALSE}
#1
#Select specific columns of interest from the dataset.
My_EDU01a <- EDU01a |>
  select("area_name" = Area_name, STCOU, ends_with("D"))
My_EDU01a
```

This looks better but it is still difficult to read and work with.  I want to collapse all columns ending in "D" into one column called "Item_ID".  We can better manage the tibble with the results of this collapse.  

```{r, echo=TRUE, output=FALSE}
#2
#Convert the section to long formatting. 
My_EDU01a <- My_EDU01a |>
  pivot_longer(
        cols = ends_with("D"),
        names_to = "Item_ID",
        values_to = "Enrollment_Value")
My_EDU01a
```

Each value in the Item_ID column holds two pieces of information--a measurement type and a year.  The first 7 characters corresponds to the measurement type while the last to numerical values represent the year for the measurement.  The measure was straight-forward with a substr call to extract the first 7 characters of the Item_ID column.  We want our year in a four-number format but the dates overlapped with the new century.  This required a case_when approach of making sure all dates that were between 1980 and 1999 inclusive were fit with a "19" prefix; meanwhile, any numbers from 2000 to 2011 inclusive were fit with a "20" prefix.  I used some boolean operations to achieve this by look at the date and assigning it the appropriate prefix. Two new columns were created to show the result of both substr calls in the mutate column operation.


```{r, echo=TRUE, output=FALSE}
#3
#Parse Strings into numeric, survey, and measurement types.  
My_EDU01a <- My_EDU01a |>
  mutate(year = case_when(
        substr(Item_ID, 8, 9) > 24 ~ paste0("19", substr(Item_ID, 8,9)),  
        substr(Item_ID, 8, 9) <= 24 ~ paste0("20", substr(Item_ID, 8,9))),
        measure = substr(Item_ID, 1, 7))
```

Our data can be broken out into two buckets; observations that are county and those that are non-county.  I used the filter operation to check each row and assign observations into one of two partitions depending on area_name formating.  I added a column for class that we will use later in the visualization section.


```{r, echo=TRUE, output=FALSE}
# 4 From the parameterized version of the EDU table, I have separated out the two tables by county and non-county. 
County.Data <- My_EDU01a |> filter(grepl(", [A-Z][A-Z]", area_name))
NonCounty.Data <- My_EDU01a |> filter(!grepl(", [A-Z][A-Z]", area_name))

# Add a column that identifies the classification of data we are working with. 
class(County.Data) <- c("county", class(County.Data))
class(NonCounty.Data) <- c("state", class(NonCounty.Data))

County.Data
NonCounty.Data
```

The final two steps involve adding a column specific to each tibble.  For the tibble capturing county data, I have added a mutate operation which checks the area_name column and extracts the last two letters to the new column.  The tibble for state was much more complicated.  There exists many divisions that make up areas by state.  I approached this using the case_when operation.  Rows belonging to particular states where funneled into their appropriate divisions.  If the area name did not contain the name of the state the new column value would be assigned "Error".  

```{r, echo=TRUE, output=FALSE}
# Create column in the County dataset that returns State
County.Data <- County.Data |> mutate(state = substr(area_name, nchar(area_name) - 1, nchar(area_name)))

# Create column in the NonCounty dataset that returns division conditionally  
NonCounty.Data <- NonCounty.Data |> mutate(division = case_when(
    area_name %in% c("CONNECTICUT","MAINE","MASSACHUSETTS","NEW HAMPSHIRE","RHODE ISLAND","VERMONT") ~ "New England",
    area_name %in% c("NEW JERSEY","NEW YORK","PENNSYLVANIA") ~ "Midwest",
    area_name %in% c("ILLINOIS","INDIANA","MICHIGAN","OHIO","WISCONSIN") ~ "East North Central",
    area_name %in% c("IOWA","KANSAS","MINNESOTA","MISSOURI","NEBRASKA","NORTH DAKOTA","SOUTH DAKOTA") ~ "West North Central",
    area_name %in% c("DELAWARE","FLORIDA","GEORGIA","MARYLAND","NORTH CAROLINA","SOUTH CAROLINA","VIRGINIA","WASHINGTON, D.C.","WEST VIRGINIA") ~ "South Atlantic",
    area_name %in% c("ALABAMA","KENTUCKY","MISSISSIPPI","TENNESSEE") ~ "East South Central",
    area_name %in% c("ARKANSAS","LOUISIANA","OKLAHOMA","TEXAS") ~ "West South Central",
    area_name %in% c("ARIZONA","COLORADO","IDAHO","MONTANA","NEVADA","NEW MEXICO","UTAH","WYOMING") ~ "Mountain",
    area_name %in% c("ALASKA","CALIFORNIA","HAWAII","OREGON","WASHINGTON") ~ "Pacific",
    TRUE ~ "ERROR"
))

County.Data
NonCounty.Data
```



  
# Combining Data Functions

Instead of running each individual code chunk, we could create a function 

```{r, echo=TRUE, output=FALSE}
# First Function performs steps 1 and 2 in earlier example. 
MyFunct0102 <- function(dataset_select_pivot, Enrollment_Values = Enrollment_Values) {
  dataset_select_pivot %>%
      select("area_name" = Area_name, STCOU, ends_with("D")) %>%
      pivot_longer(
        cols = ends_with("D"),
        names_to = "Item_ID",
        values_to = "Enrollment_Value")
}


# Second Function performs step 3 in earlier example. 
MyFunct03 <- function(dataset_mutate) {
  dataset_mutate %>%
    mutate(year = case_when(
      substr(Item_ID, 8, 9) > 24 ~ paste0("19", substr(Item_ID, 8,9)),  
      substr(Item_ID, 8, 9) <= 24 ~ paste0("20", substr(Item_ID, 8,9))),
      measure = substr(Item_ID, 1, 7))
}


##Step 5--Add state abbreviations to County Data
MyFunct05 <- function(County_Data_Mutate){
  County_Data <- County_Data_Mutate |> mutate(state = substr(area_name, nchar(area_name) - 1, nchar(area_name)))
}


#Step 6--Add Divisional descriptors to the NonCounty Data
MyFunct06 <- function(NonCounty_Data_Mutate){
  NonCounty_Data <- NonCounty_Data_Mutate |> mutate(division = case_when(
    area_name %in% c("CONNECTICUT","MAINE","MASSACHUSETTS","NEW HAMPSHIRE","RHODE ISLAND","VERMONT") ~ "New England",
    area_name %in% c("NEW JERSEY","NEW YORK","PENNSYLVANIA") ~ "Midwest",
    area_name %in% c("ILLINOIS","INDIANA","MICHIGAN","OHIO","WISCONSIN") ~ "East North Central",
    area_name %in% c("IOWA","KANSAS","MINNESOTA","MISSOURI","NEBRASKA","NORTH DAKOTA","SOUTH DAKOTA") ~ "West North Central",
    area_name %in% c("DELAWARE","FLORIDA","GEORGIA","MARYLAND","NORTH CAROLINA","SOUTH CAROLINA","VIRGINIA","WASHINGTON, D.C.","WEST VIRGINIA") ~ "South Atlantic",
    area_name %in% c("ALABAMA","KENTUCKY","MISSISSIPPI","TENNESSEE") ~ "East South Central",
    area_name %in% c("ARKANSAS","LOUISIANA","OKLAHOMA","TEXAS") ~ "West South Central",
    area_name %in% c("ARIZONA","COLORADO","IDAHO","MONTANA","NEVADA","NEW MEXICO","UTAH","WYOMING") ~ "Mountain",
    area_name %in% c("ALASKA","CALIFORNIA","HAWAII","OREGON","WASHINGTON") ~ "Pacific",
    TRUE ~ "ERROR"))
}


# Third Function that performs steps 4 in the earlier example.  This one also calls MyFunct05 and MyFunct06
#MyFunct04 <- function(dataset_partition) {
MyFunct04 <- function(dataset_partition) {  

  #Step 4--Seperate the data into its two parts--County and NonCounty
  County_Data <- dataset_partition |> filter(grepl(", [A-Z][A-Z]", area_name))
  NonCounty_Data <- dataset_partition |> filter(!grepl(", [A-Z][A-Z]", area_name))
  
  #Function Call for CountyData
  County_Data <- MyFunct05(County_Data)
  class(County_Data) <- c("county", class(County_Data))
  #Function Call for NonCountyData
  NonCounty_Data <- MyFunct06(NonCounty_Data)
  class(NonCounty_Data) <- c("state", class(NonCounty_Data))
  
  return(list(County_Data = County_Data, NonCounty_Data = NonCounty_Data))
}


#The Wrapper Function
Split_Data_Along_Geography <- function(url, Enrollment_Value = "Enrollment_Value") {
  if (!str_ends(url, ".csv")) {
    stop("Invalid URL format. Please provide a valid URL ending in '.csv") #Check satisfying conditions for running the function. 
  }
  result <- as_tibble(read_csv(url)) %>% #Reads in data.
    MyFunct0102 %>% #Selects/Pivots Data
    MyFunct03 %>% #Creates new columns for measuring and date=year
    MyFunct04 #Performs the split, mutate and class call on the dataset
}
```


```{r, echo=TRUE, output=FALSE}
# Call it and Combine your Data.  Testing to see if the URLs produce the intended outcome so far. 
result_a <- Split_Data_Along_Geography("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv", Enrollment_Value)
result_b <- Split_Data_Along_Geography("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv", Enrollment_Value)
```


```{r, echo=TRUE, output=FALSE}
# This function automates the step above, taking two URLs and producing a list of combined Tibbles seperated by County and NonCounty. 
combine_results <- function(result_a, result_b) {
  combined_county <- dplyr::bind_rows(result_a$County_Data, result_b$County_Data)
  combined_NonCounty <- dplyr::bind_rows(result_a$NonCounty_Data, result_b$NonCounty_Data)
  return(list(combined_county,combined_NonCounty))}

Frames_Joined_On_Geo <- combine_results(result_a, result_b)
```




# Generic Functions

```{r, echo=TRUE, output=FALSE}
#Plotting for our state data
plot.state <- function(df.state, var_name = "Enrollment_Value") {
  # Filter out rows where Division is "ERROR" and compute mean enrollment of the input var_name, all by division and year.
  df_filtered <- df.state %>%
    filter(division != "ERROR") %>%
    group_by(division, year) %>%
    summarize(mean_enrollment = mean(get(var_name), na.rm = TRUE))

  # Plot the input
  ggplot(df_filtered, aes(x = year, y = mean_enrollment, color = division))+
    geom_line(aes(group = division)) +
    geom_point() +
    labs(x = "Year", y = "Mean Enrollment Values") + 
    ggtitle(paste("Mean", var_name, "across years by division"))
    }
```

```{r, eval=FALSE, echo=TRUE}
#Plotting for our county data
plot.county <- function(df.county, state="AK", top_or_bottom = "top", top_bottom_count = 5, var_name = "Enrollment_Value") {
  #Input assessment to make sure all values are in proper formatting
  state <- as.character(state)
  #var_name <- as.character(var_name)
  top_or_bottom <- match.arg(top_or_bottom, choices = c("top", "bottom"))
  n <- as.integer(top_bottom_count)
  
  #Filter data down to state from the input
  state_data <- subset(df.county, state == state)

  #Find the mean of the statistic for all area_names
  means_by_area <- aggregate(get(var_name) ~ area_name, df.county = state_data, FUN = mean)
  colnames(means_by_area)[2] <- "mean_stat"
  
  #Sort and top or bottom observations
  if (top_or_bottom == "top") {
    sorted_means <- means_by_area[order(-means_by_area$mean_stat), ]
  } else {
    sorted_means <- means_by_area[order(means_by_area$mean_stat), ]
  }
  
  #Count number of observations to be returned
  top_bottom_areas <- head(sorted_means, n)
  
  #Combine all the requirements into this culminating step and return what the function was built to return.
  filtered_data <- subset(state_data, area_name %in% top_bottom_areas$area_name)
  
  return(filtered_data) #Delete this and funnel the return into a ggplot call
  
    # Plot the input
  #ggplot(df_filtered, aes(x = year, y = mean_enrollment, color = division))+
  #  geom_line(aes(group = division)) +
  #  geom_point() +
  #  labs(x = "Year", y = "Mean Enrollment Values") + 
  #  ggtitle(paste("Mean", var_name, "across years by division"))
  #  
  
  
}

plot.county(Frames_Joined_On_Geo[[1]], state = "FL", top_or_bottom = "top", top_bottom_count = 6, var_name = "Enrollment_Value")

```

### Putting it all together

Run your data processing function on the two enrollment URLs given previously, specifying an appropriate name for the enrollment data column.
```{r}
#READ: EDU01a.csv file.
EDU01a <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv")

#Combine Step one, step two and step three into one task.
My_EDU01a <- EDU01a |>
  select("area_name" = Area_name, STCOU, ends_with("D")) |>
  pivot_longer(
    cols = ends_with("D"),
    names_to = "Item_ID",
    values_to = "Enrollment_Value") |> #Specification of the enrollment values data column
  mutate(year = case_when(
    substr(Item_ID, 8, 9) > 24 ~ paste0("19", substr(Item_ID, 8,9)),  
    substr(Item_ID, 8, 9) <= 24 ~ paste0("20", substr(Item_ID, 8,9))),
    measure = substr(Item_ID, 1, 7))

#Assigned data based on area_name column values.
County.Data <- My_EDU01a |> filter(grepl(", [A-Z][A-Z]", area_name))
NonCounty.Data <- My_EDU01a |> filter(!grepl(", [A-Z][A-Z]", area_name))

#Add a column that identifies the classification of data we are working with. 
class(County.Data) <- c("county", class(County.Data))
class(NonCounty.Data) <- c("state", class(NonCounty.Data))

#Create column with state abbreviation
County.Data <- County.Data |> mutate(state = substr(area_name, nchar(area_name) - 1, nchar(area_name)))

#Create column in the NonCounty dataset that returns division conditionally  
NonCounty.Data <- NonCounty.Data |> mutate(division = case_when(
  area_name %in% c("CONNECTICUT","MAINE","MASSACHUSETTS","NEW HAMPSHIRE","RHODE ISLAND","VERMONT") ~ "New England",
  area_name %in% c("NEW JERSEY","NEW YORK","PENNSYLVANIA") ~ "Midwest",
  area_name %in% c("ILLINOIS","INDIANA","MICHIGAN","OHIO","WISCONSIN") ~ "East North Central",
  area_name %in% c("IOWA","KANSAS","MINNESOTA","MISSOURI","NEBRASKA","NORTH DAKOTA","SOUTH DAKOTA") ~ "West North Central",
  area_name %in% c("DELAWARE","FLORIDA","GEORGIA","MARYLAND","NORTH CAROLINA","SOUTH CAROLINA","VIRGINIA","WASHINGTON, D.C.","WEST VIRGINIA") ~ "South Atlantic",
  area_name %in% c("ALABAMA","KENTUCKY","MISSISSIPPI","TENNESSEE") ~ "East South Central",
  area_name %in% c("ARKANSAS","LOUISIANA","OKLAHOMA","TEXAS") ~ "West South Central",
  area_name %in% c("ARIZONA","COLORADO","IDAHO","MONTANA","NEVADA","NEW MEXICO","UTAH","WYOMING") ~ "Mountain",
  area_name %in% c("ALASKA","CALIFORNIA","HAWAII","OREGON","WASHINGTON") ~ "Pacific",
  TRUE ~ "ERROR"
))
County.Data
NonCounty.Data
```


```{r}
#READ: EDU01b.csv file.
EDU01b <- read_csv("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv")

#Combine Step one, step two and step three into one task.
My_EDU01b <- EDU01b |>
  select("area_name" = Area_name, STCOU, ends_with("D")) |>
  pivot_longer(
    cols = ends_with("D"),
    names_to = "Item_ID",
    values_to = "Enrollment_Value") |> #Specification of the enrollment values data column
  mutate(year = case_when(
    substr(Item_ID, 8, 9) > 24 ~ paste0("19", substr(Item_ID, 8,9)),  
    substr(Item_ID, 8, 9) <= 24 ~ paste0("20", substr(Item_ID, 8,9))),
    measure = substr(Item_ID, 1, 7))

#Assigned data based on area_name column values.
County.Data <- My_EDU01b |> filter(grepl(", [A-Z][A-Z]", area_name))
NonCounty.Data <- My_EDU01b |> filter(!grepl(", [A-Z][A-Z]", area_name))

#Add a column that identifies the classification of data we are working with. 
class(County.Data) <- c("county", class(County.Data))
class(NonCounty.Data) <- c("state", class(NonCounty.Data))

#Create column with state abbreviation
County.Data <- County.Data |> mutate(state = substr(area_name, nchar(area_name) - 1, nchar(area_name)))

#Create column in the NonCounty dataset that returns division conditionally  
NonCounty.Data <- NonCounty.Data |> mutate(division = case_when(
  area_name %in% c("CONNECTICUT","MAINE","MASSACHUSETTS","NEW HAMPSHIRE","RHODE ISLAND","VERMONT") ~ "New England",
  area_name %in% c("NEW JERSEY","NEW YORK","PENNSYLVANIA") ~ "Midwest",
  area_name %in% c("ILLINOIS","INDIANA","MICHIGAN","OHIO","WISCONSIN") ~ "East North Central",
  area_name %in% c("IOWA","KANSAS","MINNESOTA","MISSOURI","NEBRASKA","NORTH DAKOTA","SOUTH DAKOTA") ~ "West North Central",
  area_name %in% c("DELAWARE","FLORIDA","GEORGIA","MARYLAND","NORTH CAROLINA","SOUTH CAROLINA","VIRGINIA","WASHINGTON, D.C.","WEST VIRGINIA") ~ "South Atlantic",
  area_name %in% c("ALABAMA","KENTUCKY","MISSISSIPPI","TENNESSEE") ~ "East South Central",
  area_name %in% c("ARKANSAS","LOUISIANA","OKLAHOMA","TEXAS") ~ "West South Central",
  area_name %in% c("ARIZONA","COLORADO","IDAHO","MONTANA","NEVADA","NEW MEXICO","UTAH","WYOMING") ~ "Mountain",
  area_name %in% c("ALASKA","CALIFORNIA","HAWAII","OREGON","WASHINGTON") ~ "Pacific",
  TRUE ~ "ERROR"
))
County.Data
NonCounty.Data
```

Run your data combining function to put these into one object (with two data frames)
```{r}
#Enter URL and variable input into function to assign an object in the environment.
result_a <- Split_Data_Along_Geography("https://www4.stat.ncsu.edu/~online/datasets/EDU01a.csv", Enrollment_Value)
result_b <- Split_Data_Along_Geography("https://www4.stat.ncsu.edu/~online/datasets/EDU01b.csv", Enrollment_Value)

#Combine the resulting lists containing two tibbles such that state combines with state and county combines with county.
joined_results <- combine_results(result_a, result_b)
joined_results
```

Use the plot function on the state data frame
```{r}
#Plot state from joined_results list element 2 (the state tibble)
plot.state(joined_results[[2]])
```
 
Use the plot function on the county data frame
```{r, eval=FALSE, echo=TRUE}
#Once specifying the state to be “NC”, the group being the top, the number looked at being 20
plot.county(joined_results[[1]],state="NC", top_or_bottom = "top", top_bottom_count = 20, var_name = "Enrollment_Value")
```
```{r, eval=FALSE, echo=TRUE}
#Once specifying the state to be “SC”, the group being the bottom, the number looked at being 7
plot.county(joined_results[[1]],state="SC", top_or_bottom = "bottom", top_bottom_count = 7, var_name = "Enrollment_Value")
```
```{r, eval=FALSE, echo=TRUE}
#Once without specifying anything (defaults used)
plot.county(joined_results[[1]])
```
```{r, eval=FALSE, echo=TRUE}
#Once specifying the state to be “PA”, the group being the top, the number looked at being 8
plot.county(joined_results[[1]],state="PA", top_or_bottom = "top", top_bottom_count = 8, var_name = "Enrollment_Value")
```


Lastly, read in another couple similar data sets and apply your functions! Run your data processing function on the four data sets at URLs given below:
 – https://www4.stat.ncsu.edu/~online/datasets/PST01a.csv
 – https://www4.stat.ncsu.edu/~online/datasets/PST01b.csv
 – https://www4.stat.ncsu.edu/~online/datasets/PST01c.csv
 – https://www4.stat.ncsu.edu/~online/datasets/PST01d.csv
```{r}
``` 
 
Run your data combining function (probably three times) to put these into one object (with two data frames)
```{r}
```

Use the plot function on the state data frame
```{r, eval=FALSE, echo=TRUE}
plot.state([[2]])
```

Use the plot function on the county data frame
```{r, eval=FALSE, echo=TRUE}
#Once specifying the state to be “CA”, the group being the top, the number looked at being 15
plot.county(,state="CA", top_or_bottom = "top", top_bottom_count = 15, var_name = "Enrollment_Value")
```
```{r, eval=FALSE, echo=TRUE}
#Once specifying the state to be “TX”, the group being the top, the number looked at being 4
plot.county(,state="TX", top_or_bottom = "top", top_bottom_count = 4, var_name = "Enrollment_Value")
```
```{r, eval=FALSE, echo=TRUE}
#Once without specifying anything (defaults used)
plot.county()
```
```{r, eval=FALSE, echo=TRUE}
#Once specifying the state to be “NY”, the group being the top, the number looked at being 1
plot.county(,state="NY", top_or_bottom = "top", top_bottom_count = 1, var_name = "Enrollment_Value")
```